/*
 * Copyright (C)
 * Filename: dnsmega_adm.c
 * Author:
 * mogu <mogu.lwp@alibaba-inc.com>
 * Description:
 */

#include "dnsmega_adm.h"
#include "config.h"

#define IP_LEN 15
#define DNS_TYPE_LEN 2
#define DNS_OP_RD_LEN 1
#define OPTEND -1

const char *const short_options = "hvCDd:Sbwt:I";
const struct option long_options[] = {
    {"help", 0, NULL, 'h'},
    {"version", 0, NULL, 'v'},
    {"show", 1, NULL, 'S'},
    {"clearall", 0, NULL, 'C'},
    {"clear", 1, NULL, 'c'},
    {"blacklist", 1, NULL, 'b'},
    {"whitelist", 1, NULL, 'w'},
    {"type", 1, NULL, 't'},
    {"domain", 1, NULL, 'd'},
};

int sockfd;

void usage(void)
{
    printf
        ("DNS Mega administration tool.\n"
        "Usage: dnsmega_adm <command> [options]\n\n"
        "Commands:\n"
        "  -S --show         show a cache in DNS Mega\n"
        "  -I --IPlimit      show IPs which was limited by qps\n"
        "  -D --delete       delete a cache in DNS Mega\n"
        "  -C --clear        clear all the cache in DNS Mega\n"
        "  -b --blacklist    load a black list file\n"
        "  -w --whitelist    load a white list file\n"
        "  -v --version      display current version\n"
        "  -h --help         display this help message\n"
        "Options:\n"
        "  -d --domain       domain name\n"
        "  -t --type         domain type\n"
        "  -f --file         filename\n"
        "  -i --iplimit      IP\n"
        "Examples:\n"
        "  dnsmega_adm -I 127.0.0.1\n"
        "  dnsmega_adm -S -d myexamplezone1.org -t A\n"
        "  dnsmega_adm -D -d myexamplezone1.org -t A\n"
        "  dnsmega_adm -b -f blacklist_file\n"
        "  dnsmega_adm -w -f whitelist_file\n"
        "  dnsmega_adm -h\n");
}

int is_ipv4(const char *str)
{
    struct in_addr addr;
    int ret;

    ret = inet_pton(AF_INET, str, &addr);
    if (ret > 0) {
        return DM_SUCCESS;
    }
    printf("%s is not a valid ipv4 address\n", str);
    return DM_ERROR;
}

/*
 * domain is a nature name string,like www.taobao.com.
 * type is a nature type string, like A,CNAME.
 * key is generated by qname,qtype and option rd for kernel to search in Mega.
 * return: the length of key.
 */
static int gen_key(char *domain, char *type, char *key)
{
    int L, i, j, rd;
    if (domain == NULL || type == NULL) {
        printf("need domain and type\n");
        return DM_ERROR;
    }
    L = strlen(domain);
    int pos = 0, size = 0;
    for (i = 0; i < L; i++) {
        if (domain[i] == '.') {
            key[size++] = i - pos;
            for (j = pos; j < i; j++) {
                key[size++] = domain[j];
            }
            pos = i + 1;
        }
    }
    key[size++] = 0;
    int typenum;
    if (!strcmp(type, "A")) {
        typenum = 0x01;
    } else if (!strcmp(type, "CNAME")) {
        typenum = 0x05;
    } else {
        printf("%s not surported\n", type);
        return DM_ERROR;
    }
    rd = 1;
    memcpy(key + size, &rd, 1);
    memcpy(key + size + DNS_OP_RD_LEN, &typenum, 2);
    size += 2;
    return size;
}

static int gen_key_len(char *domain)
{
    int i, dotnum = 0;
    int L = strlen(domain);
    for (i = 0; i < L; i++) {
        if (domain[i] == '.')
            dotnum++;
    }
    return (L + dotnum + DNS_OP_RD_LEN + DNS_TYPE_LEN);
}

/*
 * communite with kernel to search
 * whether domain is exsited in Mega or not.
 */
static int search_domain(char *domain, char *type)
{
    /* call function recv_conf() in knl/manage.c */
    int ret = 0;
    int size = 0, len = 0, L = strlen(domain);
    char *key;
    // add a "." if domain isn't end of it.
    if (domain[L - 1] != '.') {
        domain[L ++] = '.';
    }
    len = gen_key_len(domain);
    key = (char *)malloc(sizeof(char) * len);
    size = gen_key(domain, type, key);
    if (size == DM_ERROR) {
        return DM_ERROR;
    }
    ret = setsockopt(sockfd, IPPROTO_IP, SOCKET_OPS_SET_SEARCH, key, size);
    free(key);
    if (ret != 0) {
        //printf("setsockopt error: errno = %d, errstr = %s\n", errno, strerror(errno));
        return DM_ERROR;
    }
    return DM_SUCCESS;
}

static int clear_domain(char *domain, char *type, int flag)
{
    if (flag == ONE_DOMAIN) {
        char *key;
        int len = 0, size, ret;
        len = gen_key_len(domain);
        key = (char *)malloc(sizeof(char) * len);
        size = gen_key(domain, type, key);
        if (size == DM_ERROR) {
            return DM_ERROR;
        }
        ret = setsockopt(sockfd, IPPROTO_IP, SOCKET_OPS_SET_CLEAR, key, size);
        if (ret != 0) {
            /* TODO
             * need print some error imformation
             */
        } else {
            printf("clear %s(type:%s) in cache success\n", domain, type);
        }
        free(key);
        return DM_SUCCESS;
    } else if (flag == ALL_DOMAIN) {
        /* TODO
         * clear all domain
         */
        return DM_SUCCESS;
    } else {
        printf("clear domain error!\n");
        return DM_ERROR;
    }
}

static int show_qpslimit(char *result) {
    int ret;
    socklen_t size = 17500;
    ret = setsockopt(sockfd, IPPROTO_IP, SOCKET_OPS_SET_LIMITIP, NULL, 0);
    if (ret == DM_ERROR) {
        return ret;
    }
    ret = getsockopt(sockfd, IPPROTO_IP, SOCKET_OPS_GET_LIMITIP, result, &size);
    if (ret == DM_ERROR) {
        return ret;
    }
    return DM_SUCCESS;
}

static int parse_opt(int argc, char **argv) {
    int i, ret;
    int result;
    int flag = DM_CMD_INIT;
    char type[10], domain[256];
    char show[17500], *temp;
    time_t ts;
    struct tm *tp;
    struct cache_info *info;
    socklen_t size;
    strcpy(type, DEFAULT_TYPE);
    while ((ret =
            getopt_long(argc, argv, short_options, long_options,
                        NULL)) != OPTEND) {
        switch (ret) {
            case 'h':
                usage();
                break;
            case 'v':
                printf("DNS Mega Version is v%d.%d.%d\n", MAJOR_VERSION,
                    MINOR_VERSION, PATCH_VERSION);
                break;
            case 'S':
                flag = DM_CMD_SHOW;
                break;
            case 'D':
                flag = DM_CMD_DELETE;
                break;
            case 'd':
                strcpy(domain, optarg);
                break;
            case 't':
                strcpy(type, optarg);
                break;
            case 'I':
                flag = DM_CMD_QPSLIMIT_SHOW;
                break;
            default:
                printf("argument error\n");
                flag = DM_CMD_ERR;
                usage();
                break;
        }
    }

    if (flag == DM_CMD_ERR || flag == DM_CMD_INIT) {
        usage();
        return DM_SUCCESS;
    }
    /*
     * create socket between user space and kernel space.
     */
    sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (sockfd < 0) {
        printf("can not create set socket\n");
        return DM_ERROR;
    }
    if (flag == DM_CMD_DELETE) {
        /*
         * clear one domain if it is in Mega.
         */
        result = clear_domain(domain, type, ONE_DOMAIN);
        if (result == DM_ERROR) {
            printf("clear domain:%s error\n", domain);
            close(sockfd);
            return DM_ERROR;
        }
    } else if (flag == DM_CMD_SHOW) {
        /*
         * search a domain in Mega.
         */
        result = search_domain(domain, type);
        if (result == DM_ERROR) {
            printf("%s(type:%s) is not in DNS Mega\n", domain, type);
            close(sockfd);
            return DM_ERROR;
        }
        ret =
            getsockopt(sockfd, IPPROTO_IP, SOCKET_OPS_GET_SEARCH, show, &size);
        info = (struct cache_info *)show;
        /* print the result of command. */
        if (!ret) {
            printf("Answer in cache:\n");
            for (i = 0; i < info->ans_len; i++) {
                printf("%20s%10d%10s%20s\n",
                       info->ans[i].query, info->ans[i].ttl, info->ans[i].type,
                       info->ans[i].answer);
            }
            printf("\n");
            printf("Infomation in cache:\n");
            printf("%20s:%15d\n", "create_time", info->ctime);
            printf("%20s:%15d\n", "modified_time", info->mtime);
            if (info->protect) {
                printf("%20s:%15s\n", "is_protected", "Protected");
            } else {
                printf("%20s:%15s\n", "is_protected", "Unprotected");
            }
        } else {
            printf("kernel not return the result\n");
        }
    } else if (flag == DM_CMD_QPSLIMIT_SHOW) {
        result = show_qpslimit(show);
        temp = show;
        while (isspace(*temp) && strlen(temp)) temp ++;
        if (result == DM_SUCCESS && strlen(temp)) {
            time(&ts);
            tp = localtime(&ts);
            printf("%02d-%02d-%d ",
                    (1 + tp->tm_mon), tp->tm_mday, (1900 + tp->tm_year));
            printf("%02d:%02d:%02d ",
                    tp->tm_hour, tp->tm_min, tp->tm_sec);
            printf("%s\n", temp);
        } else {
            //printf("none\n");
        }
    }
    close(sockfd);
    return DM_SUCCESS;
}

int main(int argc, char **argv)
{
    int ret;
    ret = parse_opt(argc, argv);
    return 0;
}
